#include "pch.h"
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <queue>
#include <iterator>
using namespace std;

class Neighbours
{
public:
	string name_node;
	vector <string> neighbours;
};

class Graph
{
private:
	Neighbours A;
	map <string, Neighbours> graphs;
public:
	void Add_node(string name) // добавление вершины
	{
		A.name_node = "";
		graphs.insert(pair<string, Neighbours>(name, A));
	}
	void Delete_node(string name) // удаление вершины
	{
		// удаляю вершину из ключей
		for (auto it = graphs.begin(); it != graphs.end(); ++it) {
			if (it->first == name) {
				it->second.neighbours.clear();
			}
			else {
				auto itMap = graphs.find(it->first);
				auto tmp = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name);
				itMap->second.neighbours.erase(tmp);
			}
		}
		graphs.erase(name);
	}
	void Add_rib(string name1, string name2) // добавление ребра
	{
		auto itMap = graphs.begin();
		itMap = graphs.find(name1);
		itMap->second.neighbours.push_back(name2);
	}
	void Delete_rib(string name1, string name2) // удаление ребра
	{

		auto itMap = graphs.find(name1);
		auto it = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name2);
		itMap->second.neighbours.erase(it);

		itMap = graphs.find(name2);
		it = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name1);
		itMap->second.neighbours.erase(it);
	}
	void set() // вывод графа
	{
		for (auto i = graphs.begin(); i != graphs.end(); ++i)
		{
			cout << i->first << ": ";
			auto tmp = i->second.neighbours;
			for (size_t i = 0; i < tmp.size(); i++)
			{
				cout << tmp[i] + " ";
			}
			cout << "\n";
		}
	}
	bool Avail_rib(string name1, string name2)   //проверка на наличие ребра между вершинами
	{
		auto itMap = graphs.begin();
		itMap = graphs.find(name1);
		int sum = 0;
		for (size_t i = 0; i < itMap->second.neighbours.size(); i++)
		{
			if (itMap->second.neighbours[i] == name2)
				sum += 1;
			else
				sum += 0;
		}
		if (sum > 0)
		{
			auto it2_Map = graphs.begin();
			it2_Map = graphs.find(name2);
			int sum2 = 0;
			for (size_t i = 0; i < it2_Map->second.neighbours.size(); i++)
			{
				if (it2_Map->second.neighbours[i] == name1)
					sum2 += 1;
				else
					sum2 += 0;
			}
			if (sum2 > 0) {
				cout << "True, rib in both directions\n";
				return 1;
			}
			else {
				cout << "Rib from " << name1 << " to " << name2 << "\n";
				return 0;
			}

		}
		else {
			cout << "False\n";
			return 0;
		}

	}
	int BFS(string name1, string name2) // найти кратчайшее расстояние от name1 до name2. name1 - исходная вершина, name2 -конечная
	{
		queue<string> myQueue;
		vector<string> ex_nodes;

		ex_nodes.push_back(name1);
		myQueue.push(name1);
		int data = 0;
		while (myQueue.empty() != 1)
		{
			string tmp = myQueue.front();
			if (tmp == name2)
				break;
			auto itMap = graphs.find(tmp);
			for (size_t i = 0; i < itMap->second.neighbours.size(); i++)
			{
				int counter = count(ex_nodes.begin(), ex_nodes.end(), itMap->second.neighbours[i]);
				if (counter == 0)
				{
					ex_nodes.push_back(itMap->second.neighbours[i]);
					myQueue.push(itMap->second.neighbours[i]);
					if (itMap->second.neighbours[i] == name2) {
						data++;
						return data;
					}	
				}
				counter = 0;
			}
			myQueue.pop();
			data++;
		}
		return data;
	}
};



int main()
{
	setlocale(LC_ALL, "Rus");
	Graph Airplane;
	Airplane.Add_node("Paris");
	Airplane.Add_node("Berlin");
	Airplane.Add_node("Moscow");
	Airplane.Add_node("Rome");
	Airplane.Add_rib("Berlin", "Paris");
	Airplane.Add_rib("Paris", "Berlin");
	Airplane.Add_rib("Paris", "Moscow");
	Airplane.Add_rib("Paris", "Rome");
	Airplane.Add_rib("Moscow", "Paris");
	Airplane.Add_rib("Moscow", "Berlin");
	Airplane.Add_rib("Berlin", "Moscow");
	Airplane.set();
	cout << Airplane.BFS("Paris", "Berlin");
	return 0;
}
