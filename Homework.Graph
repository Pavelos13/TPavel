#include "pch.h"
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <queue>
using namespace std;

class Node
{
public:
	string name_node;
	vector <string> neighbours;
};

class Graph
{
private:
	Node A;
	map <string, Node> graphs;
	bool orientation;   // проверка на тип графа. если граф ориентированный, то orientation = 1, иначе 0 
public:
	Graph () {
		cout << "Введите тип графа: ориентированный - 1 // неориентированный - 0\n";
		int solution_user;
		cin >> solution_user;
		orientation = solution_user;
	}
	void Add_node(string name) // добавление вершины
	{
		if (orientation == 1 || orientation == 0) {
			A.name_node = "";
			graphs.insert(pair<string, Node>(name, A));
		}
	}
	void Delete_node(string name) // удаление вершины
	{
		// удаляю вершину из ключей
		for (auto it = graphs.begin(); it != graphs.end(); ++it) {
			if (it->first == name) {
				it->second.neighbours.clear();
			}
			else {
				auto itMap = graphs.find(it->first);
				auto tmp = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name);
				itMap->second.neighbours.erase(tmp);
			}
		}
		graphs.erase(name);
	}
	void Add_rib(string name1, string name2) // добавление ребра
	{
		if (orientation == 1) { // ориентированный
			auto itMap = graphs.begin();
			itMap = graphs.find(name1);
			itMap->second.neighbours.push_back(name2);
		}

		if (orientation == 0) { // неориентированный 
			auto itMap = graphs.begin();
			itMap = graphs.find(name1);
			itMap->second.neighbours.push_back(name2);

			itMap = graphs.begin();
			itMap = graphs.find(name2);
			itMap->second.neighbours.push_back(name1);
		}
	}
	void Delete_rib(string name1, string name2) // удаление ребра
	{
		if (orientation == 1) { // ориентированный
			auto itMap = graphs.find(name1);
			auto it = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name2);
			itMap->second.neighbours.erase(it);
		}

		if (orientation == 0) { //неориентированный
			auto itMap = graphs.find(name1);
			auto it = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name2);
			itMap->second.neighbours.erase(it);

			itMap = graphs.find(name2);
			it = find(itMap->second.neighbours.begin(), itMap->second.neighbours.end(), name1);
			itMap->second.neighbours.erase(it);
		}
	}
	void set() // вывод графа
	{
		for (auto i = graphs.begin(); i != graphs.end(); ++i)
		{
			cout << i->first << ": ";
			auto tmp = i->second.neighbours;
			for (size_t i = 0; i < tmp.size(); i++)
			{
				cout << tmp[i] + " ";
			}
			cout << "\n";
		}
	}
	bool Avail_rib(string name1, string name2)   //проверка на наличие ребра между вершинами
	{
		auto itMap = graphs.begin();
		itMap = graphs.find(name1);
		int sum = 0;
		for (size_t i = 0; i < itMap->second.neighbours.size(); i++)
		{
			if (itMap->second.neighbours[i] == name2)
				sum += 1;
			else
				sum += 0;
		}
		if (sum > 0)
		{
			if (orientation == 1)
				cout << "Есть ребро от " << name1 << " до " << name2 << "\n";
			if (orientation == 0)
				cout << "Ребро есть";
			return 0;
		}
		else {
			cout << "Ребра нет\n";
			return 0;
		}
	}

	void BFS(string name1, string name2) // найти кратчайшее расстояние от name1 до name2. name1 - исходная вершина, name2 -конечная
	{
		if (orientation == 1 || orientation == 0) {
			queue<string> myQueue;
			vector<string> ex_nodes;

			ex_nodes.push_back(name1);
			myQueue.push(name1);
			int data = 0;
			while (myQueue.empty() != 1)
			{
				string tmp = myQueue.front();
				if (tmp == name2)
					break;
				auto itMap = graphs.find(tmp);
				for (size_t i = 0; i < itMap->second.neighbours.size(); i++)
				{
					int counter = count(ex_nodes.begin(), ex_nodes.end(), itMap->second.neighbours[i]);
					if (counter == 0)
					{
						ex_nodes.push_back(itMap->second.neighbours[i]);
						myQueue.push(itMap->second.neighbours[i]);
						if (itMap->second.neighbours[i] == name2) {
							data++;
							cout << "Расстояние от " << name1 << " до " << name2 << " : "<< data;
							return;
						}
					}
					counter = 0;
				}
				myQueue.pop();
				data++;
			}
			cout << "Путь не найден, так как ни одна вершина не соединена с искомой";
			return;
		}
	}
};



int main()
{
	setlocale(LC_ALL, "Rus");
	Graph Airplane;
	Airplane.Add_node("Paris");
	Airplane.Add_node("Berlin");
	Airplane.Add_node("Moscow");
	Airplane.Add_rib("Paris", "Berlin");
	Airplane.Add_rib("Berlin", "Moscow");
	Airplane.set();
	Airplane.BFS("Berlin", "Paris");
	
	return 0;
}
